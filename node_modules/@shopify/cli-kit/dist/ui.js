import { AutoComplete } from './ui/autocomplete.js';
import { Input } from './ui/input.js';
import { Select } from './ui/select.js';
import { CancelExecution, Abort } from './error.js';
import { remove, exists } from './file.js';
import { info, completed, content, token, logUpdate, logToFile, stringifyMessage } from './output.js';
import { colors } from './node/colors.js';
import { relative } from './path.js';
import { isTerminalInteractive } from './environment/local.js';
import { isTruthy } from './environment/utilities.js';
import inquirer from 'inquirer';
import { Listr as OriginalListr, ListrTaskState } from 'listr2';
export function newListr(tasks, options) {
    const listr = new OriginalListr(tasks, options);
    listr.tasks.forEach((task) => {
        const loggedSubtaskTitles = [];
        task.subscribe((event) => {
            if (event.type === 'TITLE' && typeof event.data === 'string') {
                logToFile(event.data, 'INFO');
            }
        });
        task.renderHook$.subscribe(() => {
            if (task.hasSubtasks()) {
                const activeSubtasks = task.subtasks.filter((subtask) => {
                    return [ListrTaskState.PENDING, ListrTaskState.COMPLETED].includes(subtask.state);
                });
                activeSubtasks.forEach((subtask) => {
                    if (subtask.title && !loggedSubtaskTitles.includes(subtask.title)) {
                        loggedSubtaskTitles.push(subtask.title);
                        logToFile(subtask.title, 'INFO');
                    }
                });
            }
        });
    });
    return listr;
}
const started = (content, logger) => {
    const message = `${colors.yellow('❯')} ${stringifyMessage(content)}`;
    info(message, logger);
};
const failed = (content, logger) => {
    const message = `${colors.red('✖')} ${stringifyMessage(content)}`;
    info(message, logger);
};
export const task = async ({ title, task }) => {
    let success;
    started(title, logUpdate);
    try {
        const result = await task();
        success = result?.successMessage || title;
    }
    catch (err) {
        failed(title, logUpdate);
        logUpdate.done();
        throw err;
    }
    completed(success, logUpdate);
    logUpdate.done();
};
export const prompt = async (questions, debugForceInquirer = false) => {
    if (!isTerminalInteractive() && questions.length !== 0) {
        throw new Abort(content `
The CLI prompted in a non-interactive terminal with the following questions:
${token.json(questions)}
    `);
    }
    if (debugForceInquirer || isTruthy(process.env.SHOPIFY_USE_INQUIRER)) {
        const results = [];
        for (const question of questions) {
            if (question.preface) {
                info(question.preface);
            }
            const questionName = question.name;
            // eslint-disable-next-line no-await-in-loop
            const answer = (await inquirer.prompt([convertQuestionForInquirer(question)]))[questionName];
            logPromptResults(question.message, answer);
            results.push([questionName, answer]);
        }
        return Object.fromEntries(results);
    }
    else {
        const value = {};
        for (const question of questions) {
            if (question.preface) {
                info(question.preface);
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const mappedQuestion = mapper(question);
            // eslint-disable-next-line no-await-in-loop
            const answer = await mappedQuestion.run();
            value[question.name] = answer;
            logPromptResults(question.message, answer);
        }
        return value;
    }
};
function logPromptResults(questionName, answer) {
    logToFile([questionName, answer].join(' '), 'INFO');
}
export async function nonEmptyDirectoryPrompt(directory) {
    if (await exists(directory)) {
        const options = [
            { name: 'No, don’t delete the files', value: 'abort' },
            { name: 'Yes, delete the files', value: 'overwrite' },
        ];
        const relativeDirectory = relative(process.cwd(), directory);
        const questions = {
            type: 'select',
            name: 'value',
            message: `${relativeDirectory} is not an empty directory. Do you want to delete the existing files and continue?`,
            choices: options,
        };
        const choice = await prompt([questions]);
        if (choice.value === 'abort') {
            throw new CancelExecution();
        }
        remove(directory);
    }
}
export const keypress = async () => {
    process.stdin.setRawMode(true);
    return new Promise((resolve) => process.stdin.once('data', () => {
        process.stdin.setRawMode(false);
        resolve();
    }));
};
function convertQuestionForInquirer(question) {
    switch (question.type) {
        case 'input':
        case 'password':
            return question;
        case 'select':
        case 'autocomplete':
            return {
                ...question,
                type: 'list',
            };
    }
}
function mapper(question) {
    switch (question.type) {
        case 'input':
        case 'password':
            return new Input(question);
        case 'select':
            return new Select(question);
        case 'autocomplete':
            return new AutoComplete(question);
        default:
            return undefined;
    }
}
//# sourceMappingURL=ui.js.map