{
  "version": 3,
  "sources": ["../../../../node_modules/node_modules/react/cjs/react.production.min.js", "../../../../node_modules/node_modules/react/index.js", "../../../../node_modules/@shopify/hydrogen/src/storefront.ts", "../../../../node_modules/@shopify/hydrogen/src/utils/hash.ts", "../../../../node_modules/@shopify/hydrogen/src/cache/strategies.ts", "../../../../node_modules/@shopify/hydrogen/src/cache/api.ts", "../../../../node_modules/@shopify/hydrogen/src/cache/sub-request.ts", "../../../../node_modules/@shopify/hydrogen/src/cache/fetch.ts", "../../../../node_modules/@shopify/hydrogen/src/constants.ts", "../../../../node_modules/@shopify/hydrogen/src/utils/uuid.ts", "../../../../node_modules/@shopify/hydrogen/src/utils/parse-json.ts", "../../../../node_modules/@shopify/hydrogen/src/utils/warning.ts", "../../../../node_modules/@shopify/hydrogen/src/version.ts", "../../../../node_modules/@shopify/hydrogen/src/cache/in-memory.ts", "../../../../node_modules/@shopify/hydrogen/src/routing/redirect.ts", "../../../../node_modules/@shopify/hydrogen/src/routing/graphiql.ts", "../../../../node_modules/@shopify/hydrogen/src/seo/seo.ts", "../../../../node_modules/@shopify/hydrogen/src/seo/generate-seo-tags.ts", "../../../../node_modules/@shopify/hydrogen/src/index.ts"],
  "sourcesContent": ["/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var l=Symbol.for(\"react.element\"),n=Symbol.for(\"react.portal\"),p=Symbol.for(\"react.fragment\"),q=Symbol.for(\"react.strict_mode\"),r=Symbol.for(\"react.profiler\"),t=Symbol.for(\"react.provider\"),u=Symbol.for(\"react.context\"),v=Symbol.for(\"react.forward_ref\"),w=Symbol.for(\"react.suspense\"),x=Symbol.for(\"react.memo\"),y=Symbol.for(\"react.lazy\"),z=Symbol.iterator;function A(a){if(null===a||\"object\"!==typeof a)return null;a=z&&a[z]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if(\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a)throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");this.updater.enqueueSetState(this,a,b,\"setState\")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=\"\"+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return\"$\"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(\"\"+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if(\"undefined\"===k||\"boolean\"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case \"string\":case \"number\":h=!0;break;case \"object\":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=\"\"===d?\".\"+Q(h,0):d,I(c)?(e=\"\",null!=a&&(e=a.replace(P,\"$&/\")+\"/\"),R(c,b,e,\"\",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?\"\":(\"\"+c.key).replace(P,\"$&/\")+\"/\")+a)),b.push(c)),1;h=0;d=\"\"===d?\".\":d+\":\";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),\"function\"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if(\"object\"===k)throw b=String(a),Error(\"Objects are not valid as a React child (found: \"+(\"[object Object]\"===b?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":b)+\"). If you meant to render a collection of children, use an array instead.\");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,\"\",\"\",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error(\"React.Children.only expected to receive a single React element child.\");return a}};exports.Component=E;exports.Fragment=p;\nexports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \"+a+\".\");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=\"\"+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error(\"act(...) is not supported in production builds of React.\");};\nexports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\nexports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\nexports.useTransition=function(){return U.current.useTransition()};exports.version=\"18.2.0\";\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n", "import {\n  createStorefrontClient as createStorefrontUtilities,\n  type StorefrontApiResponseOk,\n} from '@shopify/hydrogen-react';\nimport type {ExecutionArgs} from 'graphql';\nimport {fetchWithServerCache, checkGraphQLErrors} from './cache/fetch';\nimport {\n  STOREFRONT_API_BUYER_IP_HEADER,\n  STOREFRONT_ID_HEADER,\n  STOREFRONT_REQUEST_GROUP_ID_HEADER,\n} from './constants';\nimport {\n  CacheNone,\n  CacheLong,\n  CacheShort,\n  CacheCustom,\n  generateCacheControlHeader,\n  type CachingStrategy,\n} from './cache/strategies';\nimport {generateUUID} from './utils/uuid';\nimport {parseJSON} from './utils/parse-json';\nimport {\n  CountryCode,\n  LanguageCode,\n} from '@shopify/hydrogen-react/storefront-api-types';\nimport {warnOnce} from './utils/warning';\nimport {LIB_VERSION} from './version';\n\ntype StorefrontApiResponse<T> = StorefrontApiResponseOk<T>;\n\nexport type I18nBase = {\n  language: LanguageCode;\n  country: CountryCode;\n};\n\nexport type StorefrontClient<TI18n extends I18nBase> = {\n  storefront: Storefront<TI18n>;\n};\n\nexport type Storefront<TI18n extends I18nBase = I18nBase> = {\n  query: <T>(\n    query: string,\n    payload?: StorefrontCommonOptions & {\n      cache?: CachingStrategy;\n    },\n  ) => Promise<T>;\n  mutate: <T>(\n    mutation: string,\n    payload?: StorefrontCommonOptions,\n  ) => Promise<T>;\n  cache?: Cache;\n  CacheNone: typeof CacheNone;\n  CacheLong: typeof CacheLong;\n  CacheShort: typeof CacheShort;\n  CacheCustom: typeof CacheCustom;\n  generateCacheControlHeader: typeof generateCacheControlHeader;\n  getPublicTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPublicTokenHeaders'];\n  getPrivateTokenHeaders: ReturnType<\n    typeof createStorefrontUtilities\n  >['getPrivateTokenHeaders'];\n  getShopifyDomain: ReturnType<\n    typeof createStorefrontUtilities\n  >['getShopifyDomain'];\n  getApiUrl: ReturnType<\n    typeof createStorefrontUtilities\n  >['getStorefrontApiUrl'];\n  isApiError: (error: any) => boolean;\n  i18n: TI18n;\n};\n\nexport type CreateStorefrontClientOptions<TI18n extends I18nBase> = Parameters<\n  typeof createStorefrontUtilities\n>[0] & {\n  cache?: Cache;\n  buyerIp?: string;\n  requestGroupId?: string | null;\n  storefrontId?: string;\n  waitUntil?: ExecutionContext['waitUntil'];\n  i18n?: TI18n;\n};\n\ntype StorefrontCommonOptions = {\n  variables?: ExecutionArgs['variableValues'] & {\n    country?: CountryCode;\n    language?: LanguageCode;\n  };\n  headers?: HeadersInit;\n  storefrontApiVersion?: string;\n};\n\nexport type StorefrontQueryOptions = StorefrontCommonOptions & {\n  query: string;\n  mutation?: never;\n  cache?: CachingStrategy;\n};\n\nexport type StorefrontMutationOptions = StorefrontCommonOptions & {\n  query?: never;\n  mutation: string;\n  cache?: never;\n};\n\nconst StorefrontApiError = class extends Error {} as ErrorConstructor;\nexport const isStorefrontApiError = (error: any) =>\n  error instanceof StorefrontApiError;\n\nconst isQueryRE = /(^|}\\s)query[\\s({]/im;\nconst isMutationRE = /(^|}\\s)mutation[\\s({]/im;\n\nfunction minifyQuery(string: string) {\n  return string\n    .replace(/\\s*#.*$/gm, '') // Remove GQL comments\n    .replace(/\\s+/gm, ' ') // Minify spaces\n    .trim();\n}\n\nconst defaultI18n: I18nBase = {language: 'EN', country: 'US'};\n\nexport function createStorefrontClient<TI18n extends I18nBase>({\n  cache,\n  waitUntil,\n  buyerIp,\n  i18n,\n  requestGroupId,\n  storefrontId,\n  ...clientOptions\n}: CreateStorefrontClientOptions<TI18n>): StorefrontClient<TI18n> {\n  if (!cache) {\n    // TODO: should only warn in development\n    warnOnce(\n      'Storefront API client created without a cache instance. This may slow down your sub-requests.',\n    );\n  }\n\n  const {\n    getPublicTokenHeaders,\n    getPrivateTokenHeaders,\n    getStorefrontApiUrl,\n    getShopifyDomain,\n  } = createStorefrontUtilities(clientOptions);\n\n  const getHeaders = clientOptions.privateStorefrontToken\n    ? getPrivateTokenHeaders\n    : getPublicTokenHeaders;\n\n  const defaultHeaders = getHeaders({contentType: 'json'});\n\n  defaultHeaders[STOREFRONT_REQUEST_GROUP_ID_HEADER] =\n    requestGroupId || generateUUID();\n  if (buyerIp) defaultHeaders[STOREFRONT_API_BUYER_IP_HEADER] = buyerIp;\n  if (storefrontId) defaultHeaders[STOREFRONT_ID_HEADER] = storefrontId;\n  if (LIB_VERSION) defaultHeaders['user-agent'] = `Hydrogen ${LIB_VERSION}`;\n\n  async function fetchStorefrontApi<T>({\n    query,\n    mutation,\n    variables,\n    cache: cacheOptions,\n    headers = [],\n    storefrontApiVersion,\n  }: StorefrontQueryOptions | StorefrontMutationOptions): Promise<T> {\n    const userHeaders =\n      headers instanceof Headers\n        ? Object.fromEntries(headers.entries())\n        : Array.isArray(headers)\n        ? Object.fromEntries(headers)\n        : headers;\n\n    query = query ?? mutation;\n\n    const queryVariables = {...variables};\n\n    if (i18n) {\n      if (!variables?.country && /\\$country/.test(query)) {\n        queryVariables.country = i18n.country;\n      }\n\n      if (!variables?.language && /\\$language/.test(query)) {\n        queryVariables.language = i18n.language;\n      }\n    }\n\n    const url = getStorefrontApiUrl({storefrontApiVersion});\n    const requestInit = {\n      method: 'POST',\n      headers: {...defaultHeaders, ...userHeaders},\n      body: JSON.stringify({\n        query,\n        variables: queryVariables,\n      }),\n    };\n\n    const [body, response] = await fetchWithServerCache(url, requestInit, {\n      cacheInstance: mutation ? undefined : cache,\n      cache: cacheOptions || CacheShort(),\n      shouldCacheResponse: checkGraphQLErrors,\n      waitUntil,\n    });\n\n    if (!response.ok) {\n      /**\n       * The Storefront API might return a string error, or a JSON-formatted {error: string}.\n       * We try both and conform them to a single {errors} format.\n       */\n      let errors;\n      try {\n        errors = parseJSON(body);\n      } catch (_e) {\n        errors = [{message: body}];\n      }\n\n      throwError(response, errors);\n    }\n\n    const {data, errors} = body as StorefrontApiResponse<T>;\n\n    if (errors?.length) throwError(response, errors, StorefrontApiError);\n\n    return data as T;\n  }\n\n  return {\n    storefront: {\n      /**\n       * Sends a GraphQL query to the Storefront API.\n       *\n       * Example:\n       *\n       * ```js\n       * async function loader ({context: {storefront}}) {\n       *   const data = await storefront.query('query { ... }', {\n       *     variables: {},\n       *     cache: storefront.CacheLong()\n       *   });\n       * }\n       * ```\n       */\n      query: <T>(\n        query: string,\n        payload?: StorefrontCommonOptions & {cache?: CachingStrategy},\n      ) => {\n        query = minifyQuery(query);\n        if (isMutationRE.test(query))\n          throw new Error('storefront.query cannot execute mutations');\n\n        return fetchStorefrontApi<T>({...payload, query});\n      },\n      /**\n       * Sends a GraphQL mutation to the Storefront API.\n       *\n       * Example:\n       *\n       * ```js\n       * async function loader ({context: {storefront}}) {\n       *   await storefront.mutate('mutation { ... }', {\n       *     variables: {},\n       *   });\n       * }\n       * ```\n       */\n      mutate: <T>(mutation: string, payload?: StorefrontCommonOptions) => {\n        mutation = minifyQuery(mutation);\n        if (isQueryRE.test(mutation))\n          throw new Error('storefront.mutate cannot execute queries');\n\n        return fetchStorefrontApi<T>({...payload, mutation});\n      },\n      cache,\n      CacheNone,\n      CacheLong,\n      CacheShort,\n      CacheCustom,\n      generateCacheControlHeader,\n      getPublicTokenHeaders,\n      getPrivateTokenHeaders,\n      getShopifyDomain,\n      getApiUrl: getStorefrontApiUrl,\n      /**\n       * Wether it's a GraphQL error returned in the Storefront API response.\n       *\n       * Example:\n       *\n       * ```js\n       * async function loader ({context: {storefront}}) {\n       *   try {\n       *     await storefront.query(...);\n       *   } catch(error) {\n       *     if (storefront.isApiError(error)) {\n       *       // ...\n       *     }\n       *\n       *     throw error;\n       *   }\n       * }\n       * ```\n       */\n      isApiError: isStorefrontApiError,\n      i18n: (i18n ?? defaultI18n) as TI18n,\n    },\n  };\n}\n\nfunction throwError<T>(\n  response: Response,\n  errors: StorefrontApiResponse<T>['errors'],\n  ErrorConstructor = Error,\n) {\n  const reqId = response.headers.get('x-request-id');\n  const reqIdMessage = reqId ? ` - Request ID: ${reqId}` : '';\n\n  if (errors) {\n    const errorMessages =\n      typeof errors === 'string'\n        ? errors\n        : errors.map((error) => error.message).join('\\n');\n\n    throw new ErrorConstructor(errorMessages + reqIdMessage);\n  }\n\n  throw new ErrorConstructor(\n    `API response error: ${response.status}` + reqIdMessage,\n  );\n}\n", "type QueryKey = string | readonly unknown[];\n\nexport function hashKey(queryKey: QueryKey): string {\n  const rawKeys = Array.isArray(queryKey) ? queryKey : [queryKey];\n  let hash = '';\n\n  // Keys from `storefront.query` are in the following shape:\n  // ['prefix', 'api-endpoint', {body:'query',headers:{}}]\n  // Since the API endpoint already contains the shop domain and api version,\n  // we can ignore the headers and only use the `body` from the payload.\n  for (const key of rawKeys) {\n    if (key != null) {\n      if (typeof key === 'object') {\n        // Queries from useQuery might not have a `body`. In that case,\n        // fallback to a safer (but slower) stringify.\n        if (!!key.body && typeof key.body === 'string') {\n          hash += key.body;\n        } else {\n          hash += JSON.stringify(key);\n        }\n      } else {\n        hash += key;\n      }\n    }\n  }\n\n  return hash;\n}\n", "export interface AllCacheOptions {\n  mode?: string;\n  maxAge?: number;\n  staleWhileRevalidate?: number;\n  sMaxAge?: number;\n  staleIfError?: number;\n}\n\nexport type CachingStrategy = AllCacheOptions;\n\nexport type NoStoreStrategy = {\n  mode: string;\n};\n\nconst PUBLIC = 'public';\nconst PRIVATE = 'private';\nexport const NO_STORE = 'no-store';\n\nconst optionMapping: {\n  [key: string]: string;\n} = {\n  maxAge: 'max-age',\n  staleWhileRevalidate: 'stale-while-revalidate',\n  sMaxAge: 's-maxage',\n  staleIfError: 'stale-if-error',\n};\n\nexport function generateCacheControlHeader(\n  cacheOptions: CachingStrategy,\n): string {\n  const cacheControl: string[] = [];\n  Object.keys(cacheOptions).forEach((key: string) => {\n    if (key === 'mode') {\n      cacheControl.push(cacheOptions[key] as string);\n    } else if (optionMapping[key]) {\n      cacheControl.push(\n        `${optionMapping[key]}=${cacheOptions[key as keyof CachingStrategy]}`,\n      );\n    }\n  });\n  return cacheControl.join(', ');\n}\n\n/**\n *\n * @public\n */\nexport function CacheNone(): NoStoreStrategy {\n  return {\n    mode: NO_STORE,\n  };\n}\n\nfunction guardExpirableModeType(overrideOptions?: CachingStrategy) {\n  if (\n    overrideOptions?.mode &&\n    overrideOptions?.mode !== PUBLIC &&\n    overrideOptions?.mode !== PRIVATE\n  ) {\n    throw Error(\"'mode' must be either 'public' or 'private'\");\n  }\n}\n\n/**\n *\n * @public\n */\nexport function CacheShort(overrideOptions?: CachingStrategy): AllCacheOptions {\n  guardExpirableModeType(overrideOptions);\n  return {\n    mode: PUBLIC,\n    maxAge: 1,\n    staleWhileRevalidate: 9,\n    ...overrideOptions,\n  };\n}\n\n/**\n *\n * @public\n */\nexport function CacheLong(overrideOptions?: CachingStrategy): AllCacheOptions {\n  guardExpirableModeType(overrideOptions);\n  return {\n    mode: PUBLIC,\n    maxAge: 3600, // 1 hour\n    staleWhileRevalidate: 82800, // 23 Hours\n    ...overrideOptions,\n  };\n}\n\n/**\n *\n * @public\n */\nexport function CacheCustom(overrideOptions: CachingStrategy): AllCacheOptions {\n  return overrideOptions as AllCacheOptions;\n}\n", "import type {CachingStrategy} from './strategies';\nimport {CacheShort, generateCacheControlHeader} from './strategies';\n\nfunction logCacheApiStatus(status: string | null, url: string) {\n  // // eslint-disable-next-line no-console\n  // console.log('\\n' + status, url);\n}\n\nfunction getCacheControlSetting(\n  userCacheOptions?: CachingStrategy,\n  options?: CachingStrategy,\n): CachingStrategy {\n  if (userCacheOptions && options) {\n    return {\n      ...userCacheOptions,\n      ...options,\n    };\n  } else {\n    return userCacheOptions || CacheShort();\n  }\n}\n\nfunction generateDefaultCacheControlHeader(\n  userCacheOptions?: CachingStrategy,\n): string {\n  return generateCacheControlHeader(getCacheControlSetting(userCacheOptions));\n}\n\n/**\n * Get an item from the cache. If a match is found, returns a tuple\n * containing the `JSON.parse` version of the response as well\n * as the response itself so it can be checked for staleness.\n */\nasync function getItem(\n  cache: Cache,\n  request: Request,\n): Promise<Response | undefined> {\n  if (!cache) return;\n\n  const response = await cache.match(request);\n  if (!response) {\n    logCacheApiStatus('MISS', request.url);\n    return;\n  }\n\n  logCacheApiStatus('HIT', request.url);\n\n  return response;\n}\n\n/**\n * Put an item into the cache.\n */\nasync function setItem(\n  cache: Cache,\n  request: Request,\n  response: Response,\n  userCacheOptions: CachingStrategy,\n) {\n  if (!cache) return;\n\n  /**\n   * We are manually managing staled request by adding this workaround.\n   * Why? cache control header support is dependent on hosting platform\n   *\n   * For example:\n   *\n   * Cloudflare's Cache API does not support `stale-while-revalidate`.\n   * Cloudflare cache control header has a very odd behaviour.\n   * Say we have the following cache control header on a request:\n   *\n   *   public, max-age=15, stale-while-revalidate=30\n   *\n   * When there is a cache.match HIT, the cache control header would become\n   *\n   *   public, max-age=14400, stale-while-revalidate=30\n   *\n   * == `stale-while-revalidate` workaround ==\n   * Update response max-age so that:\n   *\n   *   max-age = max-age + stale-while-revalidate\n   *\n   * For example:\n   *\n   *   public, max-age=1, stale-while-revalidate=9\n   *                    |\n   *                    V\n   *   public, max-age=10, stale-while-revalidate=9\n   *\n   * Store the following information in the response header:\n   *\n   *   cache-put-date   - UTC time string of when this request is PUT into cache\n   *\n   * Note on `cache-put-date`: The `response.headers.get('date')` isn't static. I am\n   * not positive what date this is returning but it is never over 500 ms\n   * after subtracting from the current timestamp.\n   *\n   * `isStale` function will use the above information to test for stale-ness of a cached response\n   */\n\n  const cacheControl = getCacheControlSetting(userCacheOptions);\n\n  // The padded cache-control to mimic stale-while-revalidate\n  request.headers.set(\n    'cache-control',\n    generateDefaultCacheControlHeader(\n      getCacheControlSetting(cacheControl, {\n        maxAge:\n          (cacheControl.maxAge || 0) + (cacheControl.staleWhileRevalidate || 0),\n      }),\n    ),\n  );\n  // The cache-control we want to set on response\n  const cacheControlString = generateDefaultCacheControlHeader(\n    getCacheControlSetting(cacheControl),\n  );\n\n  // CF will override cache-control, so we need to keep a non-modified real-cache-control\n  // cache-control is still necessary for mini-oxygen\n  response.headers.set('cache-control', cacheControlString);\n  response.headers.set('real-cache-control', cacheControlString);\n  response.headers.set('cache-put-date', new Date().toUTCString());\n\n  logCacheApiStatus('PUT', request.url);\n  await cache.put(request, response);\n}\n\nasync function deleteItem(cache: Cache, request: Request) {\n  if (!cache) return;\n\n  logCacheApiStatus('DELETE', request.url);\n  await cache.delete(request);\n}\n\n/**\n * Manually check the response to see if it's stale.\n */\nfunction isStale(request: Request, response: Response) {\n  const responseDate = response.headers.get('cache-put-date');\n  const cacheControl = response.headers.get('real-cache-control');\n  let responseMaxAge = 0;\n\n  if (cacheControl) {\n    const maxAgeMatch = cacheControl.match(/max-age=(\\d*)/);\n    if (maxAgeMatch && maxAgeMatch.length > 1) {\n      responseMaxAge = parseFloat(maxAgeMatch[1]);\n    }\n  }\n\n  if (!responseDate) {\n    return false;\n  }\n\n  const ageInMs =\n    new Date().valueOf() - new Date(responseDate as string).valueOf();\n  const age = ageInMs / 1000;\n\n  const result = age > responseMaxAge;\n\n  if (result) {\n    logCacheApiStatus('STALE', request.url);\n  }\n\n  return result;\n}\n\n/**\n *\n * @private\n */\nexport const CacheAPI = {\n  get: getItem,\n  set: setItem,\n  delete: deleteItem,\n  generateDefaultCacheControlHeader,\n  isStale,\n};\n", "import {CacheAPI} from './api';\nimport {\n  CacheShort,\n  type CachingStrategy,\n  type AllCacheOptions,\n} from './strategies.js';\n\n/**\n * Wrapper Cache functions for sub queries\n */\n\n/**\n * Cache API is weird. We just need a full URL, so we make one up.\n */\nfunction getKeyUrl(key: string) {\n  return `https://shopify.dev/?${key}`;\n}\n\nfunction getCacheOption(userCacheOptions?: CachingStrategy): AllCacheOptions {\n  return userCacheOptions || CacheShort();\n}\n\nexport function generateSubRequestCacheControlHeader(\n  userCacheOptions?: CachingStrategy,\n): string {\n  return CacheAPI.generateDefaultCacheControlHeader(\n    getCacheOption(userCacheOptions),\n  );\n}\n\n/**\n * Get an item from the cache. If a match is found, returns a tuple\n * containing the `JSON.parse` version of the response as well\n * as the response itself so it can be checked for staleness.\n * @private\n */\nexport async function getItemFromCache(\n  cache: Cache,\n  key: string,\n): Promise<undefined | [any, Response]> {\n  if (!cache) return;\n  const url = getKeyUrl(key);\n  const request = new Request(url);\n\n  const response = await CacheAPI.get(cache, request);\n\n  if (!response) {\n    return;\n  }\n\n  return [await response.json(), response];\n}\n\n/**\n * Put an item into the cache.\n * @private\n */\nexport async function setItemInCache(\n  cache: Cache,\n  key: string,\n  value: any,\n  userCacheOptions?: CachingStrategy,\n) {\n  if (!cache) return;\n\n  const url = getKeyUrl(key);\n  const request = new Request(url);\n  const response = new Response(JSON.stringify(value));\n\n  await CacheAPI.set(\n    cache,\n    request,\n    response,\n    getCacheOption(userCacheOptions),\n  );\n}\n\n/**\n *\n * @private\n */\nexport async function deleteItemFromCache(cache: Cache, key: string) {\n  if (!cache) return;\n\n  const url = getKeyUrl(key);\n  const request = new Request(url);\n\n  await CacheAPI.delete(cache, request);\n}\n\n/**\n * Manually check the response to see if it's stale.\n * @private\n */\nexport function isStale(key: string, response: Response) {\n  return CacheAPI.isStale(new Request(getKeyUrl(key)), response);\n}\n", "import {hashKey} from '../utils/hash.js';\nimport {CacheShort, CachingStrategy} from './strategies';\nimport {getItemFromCache, setItemInCache, isStale} from './sub-request';\n\nexport type FetchCacheOptions = {\n  cache?: CachingStrategy;\n  cacheInstance?: Cache;\n  cacheKey?: string | readonly unknown[];\n  shouldCacheResponse?: (body: any, response: Response) => boolean;\n  waitUntil?: ExecutionContext['waitUntil'];\n  returnType?: 'json' | 'text' | 'arrayBuffer' | 'blob';\n};\n\nfunction serializeResponse(body: any, response: Response) {\n  return [\n    body,\n    {\n      status: response.status,\n      statusText: response.statusText,\n      headers: Array.from(response.headers.entries()),\n    },\n  ];\n}\n\n// Check if the response body has GraphQL errors\n// https://spec.graphql.org/June2018/#sec-Response-Format\nexport const checkGraphQLErrors = (body: any) => !body?.errors;\n\n// Lock to prevent revalidating the same sub-request\n// in the same isolate. Note that different isolates\n// in the same colo could duplicate the revalidation\n// since this is only an in-memory lock.\n// https://github.com/Shopify/oxygen-platform/issues/625\nconst swrLock = new Set<string>();\n\n/**\n * `fetch` equivalent that stores responses in cache.\n * Useful for calling third-party APIs that need to be cached.\n * @private\n */\nexport async function fetchWithServerCache(\n  url: string,\n  requestInit: Request | RequestInit,\n  {\n    cacheInstance,\n    cache: cacheOptions,\n    cacheKey = [url, requestInit],\n    shouldCacheResponse = () => true,\n    waitUntil,\n    returnType = 'json',\n  }: FetchCacheOptions = {},\n): Promise<readonly [any, Response]> {\n  if (!cacheOptions && (!requestInit.method || requestInit.method === 'GET')) {\n    cacheOptions = CacheShort();\n  }\n\n  const doFetch = async () => {\n    const response = await fetch(url, requestInit);\n    let data;\n\n    try {\n      data = await response[returnType]();\n    } catch {\n      data = await response.text();\n    }\n\n    return [data, response] as const;\n  };\n\n  if (!cacheInstance || !cacheKey || !cacheOptions) return doFetch();\n\n  const key = hashKey([\n    // '__HYDROGEN_CACHE_ID__', // TODO purgeQueryCacheOnBuild\n    ...(typeof cacheKey === 'string' ? [cacheKey] : cacheKey),\n  ]);\n\n  const cachedItem = await getItemFromCache(cacheInstance, key);\n  // console.log('--- Cache', cachedItem ? 'HIT' : 'MISS');\n\n  if (cachedItem) {\n    const [cachedValue, cacheInfo] = cachedItem;\n\n    if (!swrLock.has(key) && isStale(key, cacheInfo)) {\n      swrLock.add(key);\n\n      // Important: Run revalidation asynchronously.\n      const revalidatingPromise = Promise.resolve().then(async () => {\n        try {\n          const [body, response] = await doFetch();\n\n          if (shouldCacheResponse(body, response)) {\n            await setItemInCache(\n              cacheInstance,\n              key,\n              serializeResponse(body, response),\n              cacheOptions,\n            );\n          }\n        } catch (error: any) {\n          if (error.message) {\n            error.message = 'SWR in sub-request failed: ' + error.message;\n          }\n\n          console.error(error);\n        } finally {\n          swrLock.delete(key);\n        }\n      });\n\n      // Asynchronously wait for it in workers\n      waitUntil?.(revalidatingPromise);\n    }\n\n    const [body, init] = cachedValue;\n    return [body, new Response(body, init)];\n  }\n\n  const [body, response] = await doFetch();\n\n  /**\n   * Important: Do this async\n   */\n  if (shouldCacheResponse(body, response)) {\n    const setItemInCachePromise = setItemInCache(\n      cacheInstance,\n      key,\n      serializeResponse(body, response),\n      cacheOptions,\n    );\n\n    waitUntil?.(setItemInCachePromise);\n  }\n\n  return [body, response];\n}\n", "export const STOREFRONT_REQUEST_GROUP_ID_HEADER =\n  'Custom-Storefront-Request-Group-ID';\nexport const STOREFRONT_API_BUYER_IP_HEADER = 'Shopify-Storefront-Buyer-IP';\nexport const STOREFRONT_ID_HEADER = 'Shopify-Storefront-Id';\n", "/*\n * Generate a UUID using crypto and fallback to Math.random if crypto is not available.\n */\nexport function generateUUID() {\n  if (typeof crypto !== 'undefined' && !!crypto.randomUUID) {\n    return crypto.randomUUID();\n  } else {\n    return `weak-${Math.random().toString(16).substring(2)}`;\n  }\n}\n", "export function parseJSON(json: any) {\n  if (String(json).includes('__proto__')) return JSON.parse(json, noproto);\n  return JSON.parse(json);\n}\nfunction noproto(k: string, v: string) {\n  if (k !== '__proto__') return v;\n}\n", "const warnings = new Set<string>();\nexport const warnOnce = (string: string) => {\n  if (!warnings.has(string)) {\n    console.warn(string);\n    warnings.add(string);\n  }\n};\n", "export const LIB_VERSION = '2023.1.3';\n", "type CacheMatch = {\n  body: Uint8Array;\n  timestamp: number;\n  status: number;\n  headers: [string, string][];\n};\n\n/**\n * This is a limited implementation of an in-memory cache.\n * It only supports the `cache-control` header.\n * It does NOT support `age` or `expires` headers.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Cache\n */\nexport class InMemoryCache implements Cache {\n  #store: Map<string, CacheMatch>;\n\n  constructor() {\n    this.#store = new Map();\n  }\n\n  add(request: RequestInfo): Promise<void> {\n    throw new Error('Method not implemented. Use `put` instead.');\n  }\n\n  addAll(requests: RequestInfo[]): Promise<void> {\n    throw new Error('Method not implemented. Use `put` instead.');\n  }\n\n  matchAll(\n    request?: RequestInfo,\n    options?: CacheQueryOptions,\n  ): Promise<readonly Response[]> {\n    throw new Error('Method not implemented. Use `match` instead.');\n  }\n\n  async put(request: Request, response: Response) {\n    if (request.method !== 'GET') {\n      throw new TypeError('Cannot cache response to non-GET request.');\n    }\n\n    if (response.status === 206) {\n      throw new TypeError(\n        'Cannot cache response to a range request (206 Partial Content).',\n      );\n    }\n\n    if (response.headers.get('vary')?.includes('*')) {\n      throw new TypeError(\"Cannot cache response with 'Vary: *' header.\");\n    }\n\n    this.#store.set(request.url, {\n      body: new Uint8Array(await response.arrayBuffer()),\n      status: response.status,\n      headers: [...response.headers],\n      timestamp: Date.now(),\n    });\n  }\n\n  async match(request: Request) {\n    if (request.method !== 'GET') return;\n\n    const match = this.#store.get(request.url);\n\n    if (!match) {\n      return;\n    }\n\n    const {body, timestamp, ...metadata} = match;\n\n    const headers = new Headers(metadata.headers);\n    const cacheControl =\n      headers.get('cache-control') || headers.get('real-cache-control') || '';\n    const maxAge = parseInt(\n      cacheControl.match(/max-age=(\\d+)/)?.[1] || '0',\n      10,\n    );\n    const swr = parseInt(\n      cacheControl.match(/stale-while-revalidate=(\\d+)/)?.[1] || '0',\n      10,\n    );\n    const age = (Date.now() - timestamp) / 1000;\n\n    const isMiss = age > maxAge + swr;\n\n    if (isMiss) {\n      this.#store.delete(request.url);\n      return;\n    }\n\n    const isStale = age > maxAge;\n\n    headers.set('cache', isStale ? 'STALE' : 'HIT');\n    headers.set('date', new Date(timestamp).toUTCString());\n\n    return new Response(body, {\n      status: metadata.status ?? 200,\n      headers,\n    });\n  }\n\n  async delete(request: Request) {\n    if (this.#store.has(request.url)) {\n      this.#store.delete(request.url);\n      return true;\n    }\n    return false;\n  }\n\n  keys(request?: Request) {\n    const cacheKeys = [] as Request[];\n\n    for (const url of this.#store.keys()) {\n      if (!request || request.url === url) {\n        cacheKeys.push(new Request(url));\n      }\n    }\n\n    return Promise.resolve(cacheKeys);\n  }\n}\n", "import {redirect} from '@remix-run/server-runtime';\nimport type {UrlRedirectConnection} from '@shopify/hydrogen-react/storefront-api-types';\nimport type {I18nBase, Storefront} from '../storefront';\n\ntype StorefrontRedirect = {\n  storefront: Storefront<I18nBase>;\n  request: Request;\n  response?: Response;\n};\n\n/**\n * Queries the Storefront API to see if there is any redirect\n * created for the current route and performs it. Otherwise,\n * it returns the response passed in the parameters. Useful for\n * conditionally redirecting after a 404 response.\n *\n * @see {@link https://help.shopify.com/en/manual/online-store/menus-and-links/url-redirect Creating URL redirects in Shopify}\n */\nexport async function storefrontRedirect({\n  storefront,\n  request,\n  response = new Response('Not Found', {status: 404}),\n}: StorefrontRedirect): Promise<Response> {\n  const {pathname, search} = new URL(request.url);\n  const redirectFrom = pathname + search;\n\n  try {\n    const {urlRedirects} = await storefront.query<{\n      urlRedirects: UrlRedirectConnection;\n    }>(REDIRECT_QUERY, {\n      variables: {query: 'path:' + redirectFrom},\n      storefrontApiVersion: '2023-01',\n    });\n\n    const location = urlRedirects?.edges?.[0]?.node?.target;\n\n    if (location) {\n      return new Response(null, {status: 302, headers: {location}});\n    }\n\n    const searchParams = new URLSearchParams(search);\n    const redirectTo =\n      searchParams.get('return_to') || searchParams.get('redirect');\n\n    if (redirectTo) {\n      if (isLocalPath(redirectTo)) {\n        return redirect(redirectTo);\n      } else {\n        console.warn(\n          `Cross-domain redirects are not supported. Tried to redirect from ${redirectFrom} to ${redirectTo}`,\n        );\n      }\n    }\n  } catch (error) {\n    console.error(\n      `Failed to fetch redirects from Storefront API for route ${redirectFrom}`,\n      error,\n    );\n  }\n\n  return response;\n}\n\nfunction isLocalPath(url: string) {\n  try {\n    // We don't want to redirect cross domain,\n    // doing so could create fishing vulnerability\n    // If `new URL()` succeeds, it's a fully qualified\n    // url which is cross domain. If it fails, it's just\n    // a path, which will be the current domain.\n    new URL(url);\n  } catch (e) {\n    return true;\n  }\n\n  return false;\n}\n\nconst REDIRECT_QUERY = `#graphql\n  query redirects($query: String) {\n    urlRedirects(first: 1, query: $query) {\n      edges {\n        node {\n          target\n        }\n      }\n    }\n  }\n`;\n", "import type {LoaderArgs} from '@remix-run/server-runtime';\nimport type {I18nBase, StorefrontClient} from '../storefront';\n\nexport function graphiqlLoader(\n  {context} = {} as LoaderArgs & {\n    context: LoaderArgs['context'] & StorefrontClient<I18nBase>;\n  },\n) {\n  if (!context?.storefront) {\n    throw new Error(\n      `GraphiQL: Hydrogen's storefront client must be injected in the loader context.`,\n    );\n  }\n\n  const url = context.storefront.getApiUrl();\n  const accessToken =\n    context.storefront.getPublicTokenHeaders()[\n      'X-Shopify-Storefront-Access-Token'\n    ];\n\n  return new Response(\n    `\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>GraphiQL</title>\n    <style>\n      body {\n        height: 100%;\n        margin: 0;\n        width: 100%;\n        overflow: hidden;\n      }\n\n      #graphiql {\n        height: 100vh;\n      }\n    </style>\n\n    <script\n      src=\"https://unpkg.com/react@17/umd/react.development.js\"\n      integrity=\"sha512-Vf2xGDzpqUOEIKO+X2rgTLWPY+65++WPwCHkX2nFMu9IcstumPsf/uKKRd5prX3wOu8Q0GBylRpsDB26R6ExOg==\"\n      crossorigin=\"anonymous\"\n    ></script>\n    <script\n      src=\"https://unpkg.com/react-dom@17/umd/react-dom.development.js\"\n      integrity=\"sha512-Wr9OKCTtq1anK0hq5bY3X/AvDI5EflDSAh0mE9gma+4hl+kXdTJPKZ3TwLMBcrgUeoY0s3dq9JjhCQc7vddtFg==\"\n      crossorigin=\"anonymous\"\n    ></script>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/graphiql/graphiql.min.css\" />\n  </head>\n\n  <body>\n    <div id=\"graphiql\">Loading...</div>\n    <script\n      src=\"https://unpkg.com/graphiql/graphiql.min.js\"\n      type=\"application/javascript\"\n    ></script>\n    <script>\n      ReactDOM.render(\n        React.createElement(GraphiQL, {\n          fetcher: GraphiQL.createFetcher({\n            url: '${url}',\n            headers: {\n              'X-Shopify-Storefront-Access-Token': '${accessToken}',\n            }\n          }),\n          defaultEditorToolsVisibility: true,\n          initialTabs: [{query: '{\\\\n  shop {\\\\n    name\\\\n  }\\\\n}'}]\n        }),\n        document.getElementById('graphiql'),\n      );\n    </script>\n  </body>\n</html>\n  `,\n    {status: 200, headers: {'content-type': 'text/html'}},\n  );\n}\n", "import React from 'react';\nimport {\n  useMatches,\n  useLocation,\n  type Params,\n  type Location,\n} from '@remix-run/react';\nimport {generateSeoTags, type Seo as SeoType} from './generate-seo-tags';\nimport {logSeoTags} from './log-seo-tags';\nimport {type Thing} from 'schema-dts';\n\nimport type {\n  LoaderFunction,\n  SerializeFrom,\n  AppData,\n} from '@remix-run/server-runtime';\n\nconst SeoLogger = React.lazy(() => import('./log-seo-tags'));\n\nexport interface SeoHandleFunction<\n  Loader extends LoaderFunction | unknown = unknown,\n  StructuredDataSchema extends Thing = Thing,\n> {\n  (args: {\n    data: Loader extends LoaderFunction ? SerializeFrom<Loader> : AppData;\n    id: string;\n    params: Params;\n    pathname: Location['pathname'];\n    search: Location['search'];\n    hash: Location['hash'];\n    key: string;\n  }): Partial<SeoType<StructuredDataSchema>>;\n}\n\ninterface SeoProps {\n  debug?: boolean;\n}\n\nexport function Seo({debug}: SeoProps) {\n  const matches = useMatches();\n  const location = useLocation();\n\n  const seoConfig = matches\n    .flatMap((match) => {\n      const {handle, ...routeMatch} = match;\n      const routeInfo = {...routeMatch, ...location};\n\n      if (handle === undefined || handle.seo === undefined) {\n        return [];\n      }\n\n      return recursivelyInvokeOrReturn(handle.seo, routeInfo);\n    })\n    .reduce((acc, current) => {\n      Object.keys(current).forEach(\n        (key) => !current[key] && delete current[key],\n      );\n\n      return {...acc, ...current};\n    }, {});\n\n  const headTags = generateSeoTags(seoConfig);\n\n  if (debug) logSeoTags(headTags);\n\n  const html = headTags.map((tag) => {\n    if (tag.tag === 'script') {\n      return React.createElement(tag.tag, {\n        ...tag.props,\n        key: tag.key,\n        dangerouslySetInnerHTML: {__html: tag.children},\n      });\n    }\n\n    return React.createElement(\n      tag.tag,\n      {...tag.props, key: tag.key},\n      tag.children,\n    );\n  });\n\n  const loggerMarkup = React.createElement(\n    React.Suspense,\n    {fallback: null},\n    React.createElement(SeoLogger, {headTags}),\n  );\n\n  return React.createElement(React.Fragment, null, html, debug && loggerMarkup);\n}\n\nexport function recursivelyInvokeOrReturn<T, R extends any[]>(\n  value: T | ((...rest: R) => T),\n  ...rest: R\n): T | Record<string, T> {\n  if (value instanceof Function) {\n    return recursivelyInvokeOrReturn<T, R>(value(...rest), ...rest);\n  }\n\n  let result: Record<string, T> = {};\n\n  if (Array.isArray(value)) {\n    result = value.reduce((acc, item) => {\n      return [...acc, recursivelyInvokeOrReturn(item)];\n    }, []);\n\n    return result;\n  }\n\n  if (value instanceof Object) {\n    const entries = Object.entries(value);\n\n    entries.forEach(([key, val]) => {\n      // @ts-expect-error\n      result[key] = recursivelyInvokeOrReturn<T, R>(val, ...rest);\n    });\n\n    return result;\n  }\n\n  return value;\n}\n", "import type {Maybe} from '@shopify/hydrogen-react/storefront-api-types';\nimport type {WithContext, Thing} from 'schema-dts';\nimport type {ComponentPropsWithoutRef} from 'react';\n\nconst ERROR_PREFIX = 'Error in SEO input: ';\n// TODO: Refactor this into more reusible validators\n// or use a library like zod to do this if we decide\n// to use it in other places. @cartogram\nconst schema = {\n  title: {\n    validate: (value: unknown) => {\n      if (typeof value === 'string' && value.length > 120) {\n        throw new Error(\n          ERROR_PREFIX.concat(\n            '`title` should not be longer than 120 characters',\n          ),\n        );\n      }\n      return value;\n    },\n  },\n  description: {\n    validate: (value: unknown) => {\n      if (typeof value === 'string' && value.length > 155) {\n        throw new Error(\n          ERROR_PREFIX.concat(\n            '`description` should not be longer than 155 characters',\n          ),\n        );\n      }\n      return value;\n    },\n  },\n  url: {\n    validate: (value: unknown) => {\n      if (typeof value === 'string' && !value.startsWith('http')) {\n        throw new Error(ERROR_PREFIX.concat('`url` should be a valid URL'));\n      }\n      return value;\n    },\n  },\n  handle: {\n    validate: (value: unknown) => {\n      if (typeof value === 'string' && !value.startsWith('@')) {\n        throw new Error(ERROR_PREFIX.concat('`handle` should start with `@`'));\n      }\n\n      return value;\n    },\n  },\n};\n\nexport interface Seo<Schema extends Thing = Thing> {\n  /**\n   * The <title> HTML element defines the document's title that is shown in a browser's title bar or a page's tab. It\n   * only contains text; tags within the element are ignored.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title\n   */\n  title?: Maybe<string>;\n  /**\n   * Generate the title from a template that includes a `%s` placeholder for the title.\n   *\n   * @example\n   * ```js\n   * {\n   *   title: 'My Page',\n   *   titleTemplate: 'My Site - %s',\n   * }\n   * ```\n   */\n  titleTemplate?: Maybe<string> | null;\n  /**\n   * The media associated with the given page (images, videos, etc). If you pass a string, it will be used as the\n   * `og:image` meta tag. If you pass an object or an array of objects, that will be used to generate\n   * `og:<type of media>` meta tags. The `url` property should be the URL of the media. The `height` and `width`\n   * properties are optional and should be the height and width of the media. The `altText` property is optional and\n   * should be a description of the media.\n   *\n   * @example\n   * ```js\n   * {\n   *   media: [\n   *     {\n   *       url: 'https://example.com/image.jpg',\n   *       type: 'image',\n   *       height: '400',\n   *       width: '400',\n   *       altText: 'A custom snowboard with an alpine color pallet.',\n   *     }\n   *   ]\n   * }\n   * ```\n   *\n   */\n  media?:\n    | Maybe<string>\n    | Partial<SeoMedia>\n    | (Partial<SeoMedia> | Maybe<string>)[];\n  /**\n   * The description of the page. This is used in the `name=\"description\"` meta tag as well as the `og:description` meta\n   * tag.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\n   */\n  description?: Maybe<string>;\n  /**\n   * The canonical URL of the page. This is used to tell search engines which URL is the canonical version of a page.\n   * This is useful when you have multiple URLs that point to the same page. The value here will be used in the\n   * `rel=\"canonical\"` link tag as well as the `og:url` meta tag.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link\n   */\n  url?: Maybe<string>;\n  /**\n   * The handle is used to generate the `twitter:site` and `twitter:creator` meta tags. Include the `@` symbol in the\n   * handle.\n   *\n   * @example\n   * ```js\n   * {\n   *   handle: '@shopify'\n   * }\n   * ```\n   */\n  handle?: Maybe<string>;\n  /**\n   * The `jsonLd` property is used to generate the `application/ld+json` script tag. This is used to provide structured\n   * data to search engines. The value should be an object that conforms to the schema.org spec. The `type` property\n   * should be the type of schema you are using. The `type` property is required and should be one of the following:\n   *\n   * - `Product`\n   * - `ItemList`\n   * - `Organization`\n   * - `WebSite`\n   * - `WebPage`\n   * - `BlogPosting`\n   * - `Thing`\n   *\n   * @example\n   * ```js\n   * {\n   *   jsonLd: {\n   *     '@context': 'https://schema.org',\n   *     '@type': 'Product',\n   *     name: 'My Product',\n   *     image: 'https://hydrogen.shop/image.jpg',\n   *     description: 'A product that is great',\n   *     sku: '12345',\n   *     mpn: '12345',\n   *     brand: {\n   *       '@type': 'Thing',\n   *       name: 'My Brand',\n   *     },\n   *     aggregateRating: {\n   *       '@type': 'AggregateRating',\n   *       ratingValue: '4.5',\n   *       reviewCount: '100',\n   *     },\n   *     offers: {\n   *       '@type': 'Offer',\n   *       priceCurrency: 'USD',\n   *       price: '100',\n   *       priceValidUntil: '2020-11-05',\n   *       itemCondition: 'https://schema.org/NewCondition',\n   *       availability: 'https://schema.org/InStock',\n   *       seller: {\n   *         '@type': 'Organization',\n   *         name: 'My Brand',\n   *       },\n   *     },\n   *   }\n   * }\n   * ```\n   *\n   * @see https://schema.org/docs/schemas.html\n   * @see https://developers.google.com/search/docs/guides/intro-structured-data\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script\n   *\n   */\n  jsonLd?: WithContext<Schema>;\n  /**\n   * The `alternates` property is used to specify the language and geographical targeting when you have multiple\n   * versions of the same page in different languages. The `url` property tells search engines about these variations\n   * and helps them to serve the correct version to their users.\n   *\n   * @example\n   * ```js\n   * {\n   *   alternates: [\n   *     {\n   *       language: 'en-US',\n   *       url: 'https://hydrogen.shop/en-us',\n   *       default: true,\n   *     },\n   *     {\n   *       language: 'fr-CA',\n   *       url: 'https://hydrogen.shop/fr-ca',\n   *     },\n   *   ]\n   * }\n   * ```\n   *\n   * @see https://support.google.com/webmasters/answer/189077?hl=en\n   */\n  alternates?: LanguageAlternate | LanguageAlternate[];\n}\n\nexport interface LanguageAlternate {\n  // Language code for the alternate page. This is used to generate the hreflang meta tag property.\n  language: string;\n  // Whether or not the alternate page is the default page. This will add the `x-default` attribution to the language\n  // code.\n  default?: boolean;\n  // The url of the alternate page. This is used to generate the hreflang meta tag property.\n  url: string;\n}\n\nexport type SeoMedia = {\n  // Used to generate og:<type of media> meta tag\n  type: 'image' | 'video' | 'audio';\n  // The url value populates both url and secure_url and is used to infer the og:<type of media>:type meta tag.\n  url: Maybe<string> | undefined;\n  // The height in pixels of the media. This is used to generate the og:<type of media>:height meta tag.\n  height: Maybe<number> | undefined;\n  // The width in pixels of the media. This is used to generate the og:<type of media>:width meta tag/\n  width: Maybe<number> | undefined;\n  // The alt text for the media. This is used to generate the og:<type of media>:alt meta tag.\n  altText: Maybe<string> | undefined;\n};\n\nexport type TagKey = 'title' | 'base' | 'meta' | 'link' | 'script';\n\nexport interface CustomHeadTagObject {\n  tag: TagKey;\n  props: Record<string, unknown>;\n  children?: string;\n  key: string;\n}\n\n/**\n * The `generateSeoTags` function generates the SEO title, meta, link and script (JSON Linking Data) tags for a page. It\n * pairs well with the SEO component in `@shopify/hydrogen` when building a Hydrogen Remix app, but can be used on its\n * own if you want to generate the tags yourself.\n */\nexport function generateSeoTags<\n  Schema extends Thing,\n  T extends Seo<Schema> = Seo<Schema>,\n>(seoInput: T): CustomHeadTagObject[] {\n  const output: CustomHeadTagObject[] = [];\n\n  // TODO: Type this with `Schema` when we can use `Schema` as a generic type argument.\n  let jsonLd: any = {\n    '@context': 'https://schema.org',\n    '@type': 'Thing',\n  };\n\n  for (const seoKey of Object.keys(seoInput)) {\n    const values = ensureArray(seoInput[seoKey as keyof T]);\n    let content;\n\n    if (!values) {\n      return [];\n    }\n\n    const tags = values.map((value) => {\n      const tagResults: CustomHeadTagObject[] = [];\n\n      if (!value) {\n        return tagResults;\n      }\n\n      switch (seoKey) {\n        case 'title': {\n          content = validate(schema.title, value) as string;\n\n          const title = renderTitle(seoInput?.titleTemplate, content);\n\n          tagResults.push(\n            generateTag('title', {title}),\n            generateTag('meta', {property: 'og:title', content: title}),\n            generateTag('meta', {name: 'twitter:title', content: title}),\n          );\n\n          jsonLd.name = content;\n\n          break;\n        }\n\n        case 'description':\n          content = validate(schema.description, value) as string;\n\n          tagResults.push(\n            generateTag('meta', {\n              name: 'description',\n              content,\n            }),\n            generateTag('meta', {\n              property: 'og:description',\n              content,\n            }),\n            generateTag('meta', {\n              name: 'twitter:description',\n              content,\n            }),\n          );\n\n          jsonLd.description = content;\n\n          break;\n\n        case 'url':\n          content = validate(schema.url, value) as string;\n\n          tagResults.push(\n            generateTag('meta', {property: 'og:url', content}),\n            generateTag('link', {rel: 'canonical', href: content}),\n          );\n\n          jsonLd.url = content;\n          jsonLd['@type'] = inferSchemaType(content);\n\n          break;\n\n        case 'handle':\n          content = validate(schema.handle, value) as string;\n\n          tagResults.push(\n            generateTag('meta', {name: 'twitter:site', content}),\n            generateTag('meta', {name: 'twitter:creator', content}),\n          );\n\n          break;\n\n        case 'jsonLd':\n          jsonLd = {...jsonLd, ...value};\n\n          break;\n\n        case 'media': {\n          const values = ensureArray(value as unknown as Seo['media']);\n\n          for (const media of values) {\n            if (typeof media === 'string') {\n              tagResults.push(\n                generateTag('meta', {name: 'og:image', content: media}),\n              );\n\n              jsonLd.image = media;\n            }\n\n            if (media && typeof media === 'object') {\n              const type = media.type || 'image';\n\n              // Order matters here when adding multiple media tags @see https://ogp.me/#array\n              const normalizedMedia = media\n                ? {\n                    url: media?.url,\n                    secure_url: media?.url,\n                    type: inferMimeType(media.url),\n                    width: media?.width,\n                    height: media?.height,\n                    alt: media?.altText,\n                  }\n                : {};\n\n              for (const key of Object.keys(normalizedMedia)) {\n                if (normalizedMedia[key as keyof typeof normalizedMedia]) {\n                  content = normalizedMedia[\n                    key as keyof typeof normalizedMedia\n                  ] as string;\n\n                  tagResults.push(\n                    generateTag(\n                      'meta',\n                      {\n                        property: `og:${type}:${key}`,\n                        content,\n                      },\n                      normalizedMedia.url as string,\n                    ),\n                  );\n                }\n              }\n            }\n          }\n          break;\n        }\n\n        case 'alternates': {\n          const alternates = ensureArray(value as unknown as Seo['alternates']);\n\n          for (const alternate of alternates) {\n            if (!alternate) {\n              continue;\n            }\n\n            const {language, url, default: defaultLang} = alternate;\n\n            const hrefLang = language\n              ? `${language}${defaultLang ? '-default' : ''}`\n              : undefined;\n\n            tagResults.push(\n              generateTag('link', {\n                rel: 'alternate',\n                hrefLang,\n                href: url,\n              }),\n            );\n          }\n\n          break;\n        }\n      }\n\n      return tagResults;\n    });\n\n    const entries = tags.flat();\n\n    output.push(\n      // @ts-expect-error untyped\n      entries.filter((value) => !!value),\n    );\n  }\n\n  const additionalTags = [\n    generateTag('meta', {property: 'og:type', content: 'website'}),\n    generateTag('meta', {\n      name: 'twitter:card',\n      content: 'summary_large_image',\n    }),\n  ];\n\n  return [...output, ...additionalTags]\n    .flat()\n    .sort((a, b) => a.key.localeCompare(b.key))\n    .concat(\n      // move ld+json to the end\n      generateTag('script', {\n        type: 'application/ld+json',\n        children: jsonLd as unknown as string,\n      }),\n    )\n    .flat();\n}\n\ntype MetaTagProps =\n  | ComponentPropsWithoutRef<'title'>\n  | ComponentPropsWithoutRef<'base'>\n  | ComponentPropsWithoutRef<'meta'>\n  | ComponentPropsWithoutRef<'link'>\n  | ComponentPropsWithoutRef<'script'>;\n\nfunction generateTag(\n  tagName: 'script',\n  input: ComponentPropsWithoutRef<'script'>,\n  group?: string,\n): CustomHeadTagObject;\nfunction generateTag(\n  tagName: 'title',\n  input: ComponentPropsWithoutRef<'title'>,\n  group?: string,\n): CustomHeadTagObject;\nfunction generateTag(\n  tagName: 'base',\n  input: ComponentPropsWithoutRef<'base'>,\n  group?: string,\n): CustomHeadTagObject;\nfunction generateTag(\n  tagName: 'meta',\n  input: ComponentPropsWithoutRef<'meta'>,\n  group?: string,\n): CustomHeadTagObject;\nfunction generateTag(\n  tagName: 'link',\n  input: ComponentPropsWithoutRef<'link'>,\n  group?: string,\n): CustomHeadTagObject;\nfunction generateTag(\n  tagName: TagKey,\n  input: MetaTagProps,\n  group?: string,\n): CustomHeadTagObject {\n  const tag: CustomHeadTagObject = {tag: tagName, props: {}, key: ''};\n\n  // title tags don't have props so move to children\n  if (tagName === 'title') {\n    tag.children = input.title as string;\n    tag.key = generateKey(tag);\n\n    return tag;\n  }\n\n  // also move the input children to children and delete it\n  if (tagName === 'script') {\n    tag.children = JSON.stringify(input.children);\n\n    delete input.children;\n  }\n\n  // the rest goes on props\n  tag.props = input;\n\n  // remove empty props\n  Object.keys(tag.props).forEach(\n    (key) => !tag.props[key] && delete tag.props[key],\n  );\n\n  tag.key = generateKey(tag, group);\n\n  return tag;\n}\n\nfunction generateKey(tag: CustomHeadTagObject, group?: string) {\n  const {tag: tagName, props} = tag;\n\n  if (tagName === 'title') {\n    // leading 0 moves title to the top when sorting\n    return '0-title';\n  }\n\n  if (tagName === 'meta') {\n    // leading 0 moves meta to the top when sorting exclude secure_url from the logic because the content is the same as\n    // url\n    const priority =\n      props.content === group &&\n      typeof props.property === 'string' &&\n      !props.property.endsWith('secure_url') &&\n      '0';\n    const groupName = [group, priority];\n\n    return [tagName, ...groupName, props.property || props.name]\n      .filter((x) => x)\n      .join('-');\n  }\n\n  if (tagName === 'link') {\n    const key = [tagName, props.rel, props.hrefLang || props.media]\n      .filter((x) => x)\n      .join('-');\n\n    // replace spaces with dashes, needed for media prop\n    return key.replace(/\\s+/g, '-');\n  }\n\n  return `${tagName}-${props.type}`;\n}\n\nfunction renderTitle<T extends CustomHeadTagObject['children']>(\n  template?:\n    | string\n    | ((title?: string) => string | undefined)\n    | undefined\n    | null,\n  title?: T,\n): string | undefined {\n  if (!template) {\n    return title;\n  }\n\n  if (typeof template === 'function') {\n    return template(title);\n  }\n\n  return template.replace('%s', title ?? '');\n}\n\nfunction inferMimeType(url: Maybe<string> | undefined) {\n  const ext = url && url.split('.').pop();\n\n  if (ext === 'svg') {\n    return 'image/svg+xml';\n  }\n\n  if (ext === 'png') {\n    return 'image/png';\n  }\n\n  if (ext === 'jpg' || ext === 'jpeg') {\n    return 'image/jpeg';\n  }\n\n  if (ext === 'gif') {\n    return 'image/gif';\n  }\n\n  if (ext === 'swf') {\n    return 'application/x-shockwave-flash';\n  }\n\n  if (ext === 'mp3') {\n    return 'audio/mpeg';\n  }\n\n  return 'image/jpeg';\n}\n\nexport type SchemaType =\n  | 'Product'\n  | 'ItemList'\n  | 'Organization'\n  | 'WebSite'\n  | 'WebPage'\n  | 'BlogPosting'\n  | 'Thing';\n\nfunction inferSchemaType(url: Maybe<string> | undefined): SchemaType {\n  const defaultType = 'Thing';\n\n  if (!url) {\n    return defaultType;\n  }\n\n  const routes: {type: SchemaType; pattern: RegExp | string}[] = [\n    {\n      type: 'WebSite',\n      pattern: '^/$',\n    },\n    {\n      type: 'Product',\n      pattern: '/products/.*',\n    },\n    {\n      type: 'ItemList',\n      pattern: /\\/collections$/,\n    },\n    {\n      type: 'ItemList',\n      pattern: /\\/collections\\/([^/]+)/,\n    },\n    {\n      type: 'WebPage',\n      pattern: /\\/pages\\/([^/]+)/,\n    },\n    {\n      type: 'WebSite',\n      pattern: /\\/blogs\\/([^/]+)/,\n    },\n    {\n      type: 'BlogPosting',\n      pattern: /\\/blogs\\/([^/]+)\\/([^/]+)/,\n    },\n    {\n      type: 'Organization',\n      pattern: '/policies',\n    },\n    {\n      type: 'Organization',\n      pattern: /\\/policies\\/([^/]+)/,\n    },\n  ];\n\n  const typeMatches = routes.filter((route) => {\n    const {pattern} = route;\n    const regex = new RegExp(pattern);\n    return regex.test(url);\n  });\n\n  return typeMatches.length > 0\n    ? typeMatches[typeMatches.length - 1].type\n    : defaultType;\n}\n\nfunction ensureArray<T>(value: T | T[]): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction validate(\n  schema: {validate: (data: unknown) => unknown},\n  data: unknown,\n) {\n  try {\n    return schema.validate(data);\n  } catch (error: unknown) {\n    const message = (error as Error).message;\n\n    // TODO: Discuss consistency of logging\n    // run time warnings/helpers\n    console.warn(message);\n\n    return data;\n  }\n}\n", "export * from './storefront';\nexport {\n  CacheNone,\n  CacheShort,\n  CacheLong,\n  CacheCustom,\n  generateCacheControlHeader,\n} from './cache/strategies';\nexport {InMemoryCache} from './cache/in-memory';\n\nexport {storefrontRedirect} from './routing/redirect';\nexport {graphiqlLoader} from './routing/graphiql';\nexport {Seo} from './seo/seo';\nexport {type Seo as SeoConfig} from './seo/generate-seo-tags';\nexport type {SeoHandleFunction} from './seo/seo';\n\nexport {\n  AnalyticsEventName,\n  AnalyticsPageType,\n  ExternalVideo,\n  flattenConnection,\n  getClientBrowserParameters,\n  getShopifyCookies,\n  Image,\n  MediaFile,\n  ModelViewer,\n  Money,\n  parseMetafield,\n  sendShopifyAnalytics,\n  ShopifySalesChannel,\n  ShopPayButton,\n  storefrontApiCustomScalars,\n  useMoney,\n  useShopifyCookies,\n  Video,\n} from '@shopify/hydrogen-react';\n\nexport type {\n  ClientBrowserParameters,\n  ParsedMetafields,\n  ShopifyAddToCart,\n  ShopifyAddToCartPayload,\n  ShopifyAnalytics,\n  ShopifyAnalyticsPayload,\n  ShopifyAnalyticsProduct,\n  ShopifyCookies,\n  ShopifyPageView,\n  ShopifyPageViewPayload,\n  StorefrontApiResponse,\n  StorefrontApiResponseError,\n  StorefrontApiResponseOk,\n  StorefrontApiResponseOkPartial,\n  StorefrontApiResponsePartial,\n} from '@shopify/hydrogen-react';\n"],
  "mappings": "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",
  "names": ["Le", "m", "p", "E", "ct", "ut", "pt", "ft", "lt", "ht", "gt", "dt", "yt", "mt", "be", "St", "Ae", "Pe", "Ie", "x", "t", "r", "Oe", "Y", "Z", "Ee", "_e", "ee", "ve", "Me", "n", "o", "s", "a", "i", "c", "u", "Ct", "te", "Tt", "ke", "X", "O", "I", "Rt", "_", "wt", "qe", "pr", "je"]
}
